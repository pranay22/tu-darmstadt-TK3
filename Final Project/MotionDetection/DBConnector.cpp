/*
 * This is based on the mySql connector c++ examples from http://dev.mysql.com/doc/connector-cpp
 */

#include <stdlib.h>
#include <iostream>
#include <string>

#include "mysql_connection.h"
#include "DBConnector.h"

#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include "Quadrangle.h"
#include "MotionDetector.h"
#include <stdio.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>

using namespace std;
using namespace sql::mysql;

DBConnector::DBConnector() {
	serverIP = "127.0.0.1";
	serverPort = "3306";
	user = "tk3";
	pass = "tk3";
	database = "tk3_final_project";
	roomID = 1;
}

/*
 * This expects the seat_ID(int), an occupied flag(bool) and the room ID.
 * The method then inserts the given update into the 'history' table, where the timestamp is generated by the sql server.
 * Afterward the 'seats' table is updated with the current occupied value for the given seat and room.
 */
void DBConnector::writeToDB(int seat_id, bool occupied) {

	try {
		sql::Driver *driver;
		/* Create a connection */
		driver = get_driver_instance();
		//needs to be a new one everytime, it seems this is implicitly deleted somewhere or gets stuck otherwise

		sql::Connection *con;
		sql::Statement *stmt;
		sql::PreparedStatement *prep_stmt;

		//construct connection argument
		string conToServer = "tcp://";
		conToServer += serverIP;
		conToServer += ":";
		conToServer += serverPort;

		con = driver->connect(conToServer, user, pass);
		/* Connect to the MySQL server
		 *
		 This part will fail if the used mysqlppcon libraries were compiled with a different compiler than the rest of this code
		 :(
		 */

		//Use the correct DB
		//con->setSchema(database);
		//use might be better here (?)
		stmt = con->createStatement();
		stmt->execute("USE " + database);

		delete stmt;
		//should be freed explicitly

		// Write into history table
		string query =
				"INSERT INTO history(seat_id, occupied, room_id, times) VALUES (?, ?, ?, NOW())";  //TODO timestamp? Isn't that autogenerated by the SQL table?!
		prep_stmt = con->prepareStatement(query);
		// This is a prepared command string, the '?' will be replaced with the correct values in the next step

		prep_stmt->setInt(1, seat_id);

		string isOccupied = "false";
		if (occupied)
			isOccupied = "true";

		prep_stmt->setString(2, isOccupied);
		prep_stmt->setInt(3, roomID);

		prep_stmt->execute();

		delete prep_stmt;

		//Write into seats table
		query = "UPDATE seats SET occupied = ? WHERE seat_id = ? && room_id = ?";
		prep_stmt = con->prepareStatement(query);

		prep_stmt->setString(1, isOccupied);
		prep_stmt->setInt(2, seat_id);
		prep_stmt->setInt(3, roomID);

		prep_stmt->executeUpdate();

		delete prep_stmt;

		delete con;

	} catch (sql::SQLException &e) {
		cout << "# ERR: SQLException in " << __FILE__;

		cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;

		cout << "# ERR: " << e.what();
		cout << " (MySQL error code: " << e.getErrorCode();
		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
	}
}

void DBConnector::getCoordinates(MotionDetector* md) {
	//TODO
	try {
		sql::Driver *driver;
		/* Create a connection */
		driver = get_driver_instance();
		//needs to be a new one everytime, it seems this is implicitly deleted somewhere or gets stuck otherwise

		sql::Connection *con;
		sql::Statement *stmt;
		sql::PreparedStatement *prep_stmt;

		//construct connection argument
		string conToServer = "tcp://";
		conToServer += serverIP;
		conToServer += ":";
		conToServer += serverPort;

		con = driver->connect(conToServer, user, pass);
		stmt = con->createStatement();
		stmt->execute("USE " + database);

		delete stmt;

		string query =
				"SELECT * FROM seat_cam_pos INNER JOIN seats ON seats.id = seat_cam_pos.seat_id WHERE room_id = ?;";
		prep_stmt = con->prepareStatement(query);
		prep_stmt->setInt(1, roomID);

		sql::ResultSet* res = prep_stmt->executeQuery();

		while (res->next()) {
			// constuct the seat's Position and transfer it to the motion detector module
			Quadrangle quad(Point2(res->getInt("p0_x"), res->getInt("p0_y")),
					Point2(res->getInt("p1_x"), res->getInt("p1_y")),
					Point2(res->getInt("p2_x"), res->getInt("p2_y")),
					Point2(res->getInt("p3_x"), res->getInt("p3_y")));
			md->addToList(quad, res->getInt("id"));
		}

		delete res;
		delete prep_stmt;
		delete con;
		//explicit deletion necessary

	} catch (sql::SQLException &e) {
		cout << "# ERR: SQLException in " << __FILE__;

		cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;

		cout << "# ERR: " << e.what();
		cout << " (MySQL error code: " << e.getErrorCode();
		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
	}
}

static string getIP() {
	struct ifaddrs * ifAddrStruct = NULL;
	struct ifaddrs * ifa = NULL;
	void * tmpAddrPtr = NULL;

	getifaddrs(&ifAddrStruct);

	for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {
		if (!ifa->ifa_addr) {
			continue;
		}
		if (ifa->ifa_addr->sa_family == AF_INET) {  // check it is IP4
			// is a valid IP4 Address
			tmpAddrPtr = &((struct sockaddr_in *) ifa->ifa_addr)->sin_addr;
			char addressBuffer[INET_ADDRSTRLEN];
			inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);
			if (strcmp(ifa->ifa_name, "lo") != 0) {
				if (ifAddrStruct != NULL)
						freeifaddrs(ifAddrStruct);
				return addressBuffer;
			}
		}
	}
	if (ifAddrStruct != NULL)
		freeifaddrs(ifAddrStruct);
	return NULL;
}

void DBConnector::registerNode(int port) {
	//TODO
	try {
		sql::Driver *driver;
		/* Create a connection */
		driver = get_driver_instance();
		//needs to be a new one everytime, it seems this is implicitly deleted somewhere or gets stuck otherwise

		sql::Connection *con;
		sql::Statement *stmt;
		sql::PreparedStatement *prep_stmt;

		//construct connection argument
		string conToServer = "tcp://";
		conToServer += serverIP;
		conToServer += ":";
		conToServer += serverPort;

		con = driver->connect(conToServer, user, pass);
		stmt = con->createStatement();
		stmt->execute("USE " + database);

		delete stmt;

		string query =
				"INSERT INTO tk3_final_project.rooms (room_id,tcp_info) VALUES(?, ?) ON DUPLICATE KEY UPDATE tcp_info = ?;";
		prep_stmt = con->prepareStatement(query);
		prep_stmt->setInt(1, roomID);
		string ip = getIP();
		stringstream tcp_info;
		tcp_info << ip << ":" << port;
		prep_stmt->setString(2, tcp_info.str());
		prep_stmt->setString(3, tcp_info.str());

		prep_stmt->executeQuery();

		delete prep_stmt;

		delete con;

	} catch (sql::SQLException &e) {
		cout << "# ERR: SQLException in " << __FILE__;

		cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;

		cout << "# ERR: " << e.what();
		cout << " (MySQL error code: " << e.getErrorCode();
		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
	}
}

void DBConnector::setServerIP(std::string serverIP) {
	DBConnector::serverIP = serverIP;
}

string DBConnector::getServerIP() {
	return serverIP;
}

void DBConnector::setServerPort(std::string serverPort) {
	DBConnector::serverPort = serverPort;
}

string DBConnector::getServerPort() {
	return serverPort;
}

void DBConnector::setDBUser(std::string user) {
	DBConnector::user = user;
}

void DBConnector::setDBPassword(std::string password) {
	DBConnector::pass = password;
}

void DBConnector::setDataBase(std::string dbName) {
	database = dbName;
}

void DBConnector::setRoomID(int roomID) {
	this->roomID = roomID;
}

int DBConnector::getRoomID() {
	return roomID;
}

